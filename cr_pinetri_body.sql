-- DDL Script was generated by Orange for ORACLE
-- using session 'TSQL@NGMS1' on '2015/01/06 14:23:21'.

CREATE OR REPLACE package body pinetri
is
--    type t_tf_row as object (id number, gen_dt date, logrds number); --package에서 정의가 안된다.
--    type t_tf_row is record (id number, gen_dt date, logrds number);
--    type t_tf_tab is table of t_tf_row;

--    l_row t_tf_row; --package variable
--    l_row_p t_tf_row;

    function get_perf(v_sid in number) return t_tf_row
    is
        l_return t_tf_row;
    begin

            select systimestamp into l_return.gen_dt from dual;
            select value into l_return.cpu_idle
            from v$osstat
            where stat_name in ('IDLE_TIME')
            ;

            select value into l_return.cpu_busy
            from v$osstat
            where stat_name in ('BUSY_TIME')
            ;

        if v_sid = 0 then
            select value into l_return.logrds
              from v$sysstat where stat_id = 3143187968;
            select value into l_return.phyrds
              from v$sysstat where stat_id = 2263124246;
            select value into l_return.exec
              from v$sysstat where stat_id = 2453370665;

            select sum(decode(status, 'ACTIVE', 1, 0)) ats
              into l_return.ats
              from v$session where username is not null;

            select nvl(sum(decode(wait_class, 'Application', ws, 0, 0)),0) ap,
                   nvl(sum(decode(wait_class, 'Concurrency', ws, 0, 0)),0) co
              into l_return.ap, l_return.co
              from (
            select wait_class, nvl(sum(seconds_in_wait),0) ws
              from v$session_wait where state='WAITING' and wait_class in ('Application', 'Concurrency')
               group by wait_class
               )
              ;

            select nvl(sum(used_urec),0), nvl(count(*), 0)
              into l_return.undo_rec, l_return.tx_cnt
              from v$transaction;

            select trunc(sum(value)/1048576)
              into l_return.pga_mb
              from v$sesstat s, v$statname n
            where n.name = 'session pga memory' and s.statistic# = n.statistic#;

            select evt
              into l_return.event
              from (
                 select event || '(' || to_char(count(event)) || ')' evt
                  from v$session
                 where status = 'ACTIVE'
                 group by event
                 order by count(event) desc
             ) where rownum = 1
             ;
        else
            select sum(value) into l_return.logrds
            from v$sesstat s, v$statname n
            where n.name = 'session logical reads' and s.statistic# = n.statistic#
              and (sid in (select sid from v$px_session where qcsid = v_sid) or sid = v_sid)
            ;

            select sum(value) into l_return.phyrds
            from v$sesstat s, v$statname n
            where n.name = 'physical reads' and s.statistic# = n.statistic#
              and (sid in (select sid from v$px_session where qcsid = v_sid) or sid = v_sid)
            ;

            select sum(value) into l_return.exec
            from v$sesstat s, v$statname n
            where n.name = 'execute count' and s.statistic# = n.statistic#
              and (sid in (select sid from v$px_session where qcsid = v_sid) or sid = v_sid)
            ;

            select sum(decode(status, 'ACTIVE', 1, 0)) ats
              into l_return.ats
              from v$session where username is not null --except the backgrounds?
               and  (sid in (select sid from v$px_session where qcsid = v_sid) or sid = v_sid)
               ;

            select nvl(sum(decode(wait_class, 'Application', ws, 0, 0)),0) ap,
                   nvl(sum(decode(wait_class, 'Concurrency', ws, 0, 0)),0) co
              into l_return.ap, l_return.co
              from (
            select wait_class, nvl(sum(seconds_in_wait),0) ws
              from v$session_wait where state='WAITING' and wait_class in ('Application', 'Concurrency')
               and (sid in (select sid from v$px_session where qcsid = v_sid) or sid = v_sid)
               group by wait_class
               )
              ;

            select nvl(sum(t.used_urec), 0), nvl(count(t.addr), 0)
              into l_return.undo_rec, l_return.tx_cnt
              from v$transaction t, v$session s
             where s.taddr = t.addr
               and (s.sid in (select sid from v$px_session where qcsid = v_sid) or s.sid = v_sid)
               ;

            select trunc(sum(value)/1048576)
              into l_return.pga_mb
              from v$sesstat s, v$statname n
            where n.name = 'session pga memory' and s.statistic# = n.statistic#
               and (s.sid in (select sid from v$px_session where qcsid = v_sid) or s.sid = v_sid)
               ;

            select event into l_return.event
              from v$session where  sid = v_sid;

        end if;
--        dbms_output.put_line(to_char(l_return.gen_dt) || ',' || to_char(l_return.logrds));
        return l_return;
    end;

    function get_delta(after in t_tf_row, before in t_tf_row) return t_tf_row
    is
        l_delta number;
        l_return t_tf_row;
    begin
        select extract(second from (after.gen_dt-before.gen_dt)) into l_delta from dual;

        -- dbms_output.put_line('delta-seconds:' || to_char(l_delta));
        -- l_return := after - before;
        l_return.logrds := round((after.logrds - before.logrds)/l_delta);
        l_return.phyrds := round((after.phyrds - before.phyrds)/l_delta);
        l_return.exec := round((after.exec - before.exec)/l_delta);

        l_return.cpu_busy := round(after.cpu_busy - before.cpu_busy);
        l_return.cpu_idle := round(after.cpu_busy - before.cpu_busy);
        l_return.cpu := trunc(l_return.cpu_busy*100/(l_return.cpu_busy + l_return.cpu_idle));
        l_return.ats := after.ats;
        l_return.tx_cnt := after.tx_cnt;
        l_return.ap := after.ap;
        l_return.co := after.co;
        l_return.gen_dt := after.gen_dt;
        l_return.undo_rec := after.undo_rec;
        l_return.pga_mb := after.pga_mb;
        l_return.event := after.event;
        return l_return;
    end;

--    procedure get_perf(l_return out nocopy t_tf_row)
--    is
--    begin
--        select
--               value
--          into
--               l_return.logrds
--        from   v$sysstat
--        where  STATISTIC#=12;
--    end;

    function get(p_sid in number, p_rows in number, p_interval in number) return t_tf_tab pipelined
    is
        l_first t_tf_row  := null;
        l_last t_tf_row   := null;
        l_return t_tf_row := null;
    begin

        l_first := get_perf(p_sid);

        for idx in 1..p_rows
        loop
            dbms_lock.sleep(p_interval);
            l_last := get_perf(p_sid);
            l_return := get_delta(l_last, l_first);
            l_return.id := idx;

            pipe row(l_return);
            --pipe row(t_tf_row(..)); 이 형태로는 동작하지 않는다

            l_first := l_last;
        end loop;
    end;

end pinetri;